#!/usr/bin/env ruby

require 'yaml'
require 'optparse'
require 'erb'
require 'metababel'
require 'fileutils'

def validate_model(yaml)
  # Stream and event classes must have a 'name' as minimum requirement.
  cond = yaml[:stream_classes].all?{ |d| d.key?(:name) && d[:event_classes].all? { |d2| d2.key?(:name) }}
  raise "Missing 'name' attr in model #{yaml}" unless cond 
  # Event class name must be unique
  events = yaml[:stream_classes].flat_map { |sc| sc[:event_classes] }.map { |e| e[:name] }
  raise "Duplicated 'event' in model #{yaml}" unless events.length == events.uniq.length
  yaml
end

def load_files(files)
  y = [files].flatten.reduce({}) do |y_, upstream|
    # Need to specialize for merging arrays
    y_.deep_merge(YAML.load_file(upstream)) { |_key, old, new| old + new }
  end
  validate_model(y)
end

def sanitize(str)
  str.gsub(/[^0-9A-Za-z-]/, '_')
end

class Array
  def join_with_prefix(sep)
    empty? ? '' : "#{sep}#{join(sep)}"
  end
end

class Hash
  # Copy pasted from rails (https://apidock.com/rails/Hash/deep_merge%21)
  def deep_merge!(other_hash, &block)
    merge!(other_hash) do |key, this_val, other_val|
      if this_val.is_a?(Hash) && other_val.is_a?(Hash)
        this_val.deep_merge(other_val, &block)
      elsif block_given?
        block.call(key, this_val, other_val)
      else
        other_val
      end
    end
  end

  def deep_merge(other_hash, &block)
    dup.deep_merge!(other_hash, &block)
  end
end

Matcher = Struct.new(:name, :args, :id, :dispatchers) do
  def name_sanitized
    sanitize(name)
  end
end

Dispatcher = Struct.new(:name, :args, :body, :index_stream_class,
                        :index_event_class, :default_clock_class,
                        :args_to_free, :matchers,
                        :event) do
  def name_sanitized
    sanitize(name)
  end
end

def erb_render_and_save(vars,
                        basename, out_folder, out_name: nil, prefix: 'btx_')
  template = File.read(File.join(__dir__, "../template/#{basename}.erb"))
  # We need to trim line who contain only with space, because we indent our erb block <% %>
  # The trim_mode remove line only when it's start with the erb block
  # The regex remove the lines who are not indented
  # Maybe related to `https://github.com/ruby/erb/issues/24`
  str = ERB.new(template, trim_mode: '<>').result_with_hash(vars).gsub(/^ +$\n/, '')
  File.write(File.join(out_folder, "#{prefix}#{out_name || basename}"), str)
end

class Babeltrace2Gen::BTTraceClass
  def map_event_classes_with_index
    @stream_classes.map.with_index do |s, index_stream_class|
      s.event_classes.map.with_index do |e, index_event_class|
        yield(e, index_stream_class, index_event_class, s.default_clock_class)
      end
    end.flatten(1)
  end

  def map_event_classes(&block)
    @stream_classes.map do |s|
      s.event_classes.map(&block)
    end.flatten(1)
  end
end

GeneratedArg = Struct.new(:type, :name)

# From a matching event, get the list of dispatcher who match
def get_matched_dispatchers_and_signature(dispatchers, em)
    matched_dispatchers, signatures = dispatchers.filter_map do |dispatcher|
      extracted_args = dispatcher.event.match?(em)
      [dispatcher, extracted_args] if extracted_args
    end.transpose

    # Veirfy that at least one matching
    if !matched_dispatchers or matched_dispatchers.empty?
      raise "No event matched '#{em.callback_name}', at least one matching event required."
    end

    # Verify same signature
    unique_signatures = signatures.uniq
    unless unique_signatures.size == 1
      signatures_str = unique_signatures.map { |s| "(#{s.map(&:type).join(', ')})" }.join(', ')
      raise "Conflicting signatures for '#{em.callback_name}', found #{unique_signatures.size} signatures, only one allowed: '#{signatures_str}'"
    end

    [matched_dispatchers, signatures.pop]
end

# We preprent an empty new line from the body as a hack, to correct the indentation
# Indeeed the <%= body %> will be indented, but we don't don't want it,
# in the body string is already indented
# But we clean the white space empty line afterward \o/
def wrote_event_dispatchers(folder, trace_model, trace_matching_model)
  event_var_name = '_event'

  dispatchers = trace_model.map_event_classes_with_index do |e, index_stream_class, index_event_class, default_clock_class|
    arg_variables = {}
    body = Babeltrace2Gen.context(indent: 1) do
      e.get_getter(event: event_var_name, arg_variables: arg_variables)
    end

    # automatic event dispatcher
    evt_args = []
    evt_args += [GeneratedArg.new('int64_t', '_timestamp')] if default_clock_class
    evt_args += arg_variables.fetch('outputs', [])

    matcher = Matcher.new(e.name, evt_args, 'generic', [])
    dispatcher = Dispatcher.new(
      e.name, evt_args, body, index_stream_class, index_event_class, default_clock_class,
      arg_variables.fetch('outputs_allocated', []), [matcher], e
    )
    matcher.dispatchers << dispatcher

    dispatcher
  end

  matchers = dispatchers.flat_map(&:matchers)

  matchers += trace_matching_model.map_event_classes_with_index do |em, _, _, default_clock_class|
    # Get the matching dispachers
    matched_dispatchers, args = get_matched_dispatchers_and_signature(dispatchers, em)

    # Modify the dispatcher to add the new dispatchType
    matcher_args = []
    matcher_args << GeneratedArg.new('int64_t', '_timestamp') if default_clock_class
    matcher_args << GeneratedArg.new('const char *', '_event_class_name')
    matcher_args += args

    # Create the matcher and add it to the list of dispatchers 
    matcher = Matcher.new(em.callback_name, matcher_args, "matching_#{sanitize(em.callback_name)}",
                          matched_dispatchers)

    matched_dispatchers.each do |dispatcher|
      dispatcher.matchers << matcher
    end

    matcher
  end

  d = { dispatchers: dispatchers, matchers: matchers, event_name: event_var_name }

  erb_render_and_save(d, 'upstream.h', folder)
  erb_render_and_save(d, 'upstream.c', folder)
end

def wrote_creates(folder, t, options)
  event_var_name = '_event'
  downstream_events = t.map_event_classes_with_index do |e, index_stream_class, index_event_class, default_clock_class|
    arg_variables = {}
    body = Babeltrace2Gen.context(indent: 1) do
      e.get_setter(event: event_var_name, arg_variables: arg_variables)
    end
    Dispatcher.new(e.name, arg_variables.fetch('outputs', []), "\n" + body, index_stream_class, index_event_class,
                   default_clock_class)
  end

  body_declarator_classes = "\n" + Babeltrace2Gen.context(indent: 1) do
    t.get_declarator(variable: '_trace_class', self_component: '_self_component')
  end

  d = { body_declarator_classes: body_declarator_classes,
        downstream_events: downstream_events,
        stream_classes: t.stream_classes,
        event_name: event_var_name,
        options: options }

  erb_render_and_save(d, 'downstream.h', folder)
  erb_render_and_save(d, 'downstream.c', folder)
end

def wrote_component(options, d, folder)
  static_callbacks = [Dispatcher.new('initialize_component',
                                     [GeneratedArg.new('void **', 'usr_data_p')]),
                      Dispatcher.new('finalize_component',
                                     [GeneratedArg.new('void *', 'usr_data')]),
                      Dispatcher.new('read_params',
                                     [GeneratedArg.new('void *', 'usr_data'),
                                      GeneratedArg.new('btx_params_t *', 'usr_params')])]
  # Usefull to push message
  if %w[SOURCE FILTER].include?(options[:component_type])
    static_callbacks += [Dispatcher.new('initialize_processing',
                                        [GeneratedArg.new('void *', 'usr_data_p')]),
                         Dispatcher.new('finalize_processing',
                                        [GeneratedArg.new('void *', 'usr_data')])]
  end

  if %w[SOURCE].include?(options[:component_type])
    static_callbacks << Dispatcher.new('push_usr_messages',
                                       [GeneratedArg.new('void *', 'usr_data'),
                                        GeneratedArg.new('btx_source_status_t*', 'status')])
  end

  d2 = { event_name: 'dummy_event',
         static_callback_types: static_callbacks,
         options: options }

  erb_render_and_save(d2.update(d), 'component.h', folder)
  erb_render_and_save(d2.update(d), 'component.c', folder)
end

# Display help if no arguments.
ARGV << '-h' if ARGV.empty?

options = {}
OptionParser.new do |opts|
  opts.banner = 'Usage: example.rb [options]'

  opts.on('-h', '--help', 'Prints this help') do
    puts opts
    exit
  end

  opts.on('-v', '--version', 'Prints this help') do
    puts "Ruby: #{RUBY_VERSION}"
    puts "Metababel: #{Metababel::VERSION}"
    exit
  end

  opts.on('-t', '--component TYPE', '[Mandatory] Node within a trace processing graph.') do |p|
    options[:component_type] = p
  end

  opts.on('-u', '--upstreams PATH', Array, '[Mandatory] Path to the bt2 yaml file.') do |p|
    options[:upstreams] = p
  end

  opts.on('-d', '--downstream PATH', '[Optional] Path to the bt2 yaml file.') do |p|
    options[:downstream] = p
  end

  opts.on('-p', '--plugin-name PATH', '[Optional] Name of the bt2 plugin created.') do |p|
    options[:plugin_name] = p
  end

  opts.on('-c', '--component-name PATH', '[Optional] Name of the bt2 componant created.') do |p|
    options[:component_name] = p
  end

  opts.on('--params PATH', '[Optional] Name of YAML params definition.') do |p|
    options[:params] = p
  end

  opts.on('--callbacks PATH', '[Optional] Name of YAML defining matching callbacks.') do |p|
    options[:callbacks] = p
  end

  opts.on('-o', '--output FOLDER', '[Optional] Output folder path.') do |p|
    options[:folder] = p
  end

  opts.on('-i', '--usr-data-header NAME', '[Optional] User datatypes definitions.') do |p|
    options[:usr_data_header] = p
  end

  opts.on('--enable-on-downstream-callback', '[Optional] Enable on downstream message callback .') do |p|
    options[:enable_on_downstream_callback] = p
  end
end.parse!

raise OptionParser::MissingArgument if options[:component_type].nil?

options[:plugin_name] ||= "metababel_#{options[:component_type].downcase}"
options[:component_name] ||= 'btx'

# Babeltrace can be extended by plugins, which provide one or more component classes.
base_folder = options[:folder] || "#{options[:component_type]}.#{options[:plugin_name]}.#{options[:component_name]}"
folder = "#{base_folder}/metababel"
FileUtils.mkdir_p(folder)

d = { options: options, params_declaration: nil, params_definition: nil }

if options.key?(:params)
  y = YAML.load_file(options[:params])
  c = Babeltrace2Gen::BTValueCLass.from_h(y)
  body = Babeltrace2Gen.context(indent: 1) do
    c.get('_usr_params', '_params')
  end
  d[:params_declaration] = c.get_struct_definition('_params')
  d[:params_definition] = body
end

erb_render_and_save(d, "#{options[:component_type].downcase}.c", base_folder, out_name: 'main.c')
erb_render_and_save({ options: options }, 'metababel.h', folder, prefix: '')

callback_types = ['generic']
trace_matcher = Babeltrace2Gen::BTTraceClass.new(parent: nil, stream_classes: [])

if options.key?(:callbacks)
  data = YAML.load_file(options[:callbacks])
  data[:match] = true
  trace_matcher = Babeltrace2Gen::BTTraceClass.from_h(nil, data)
  callback_types += trace_matcher.map_event_classes do |e|
    raise "Key ':callback_name' required when matching events." unless e.callback_name

    "matching_#{sanitize(e.callback_name)}"
  end
end

d[:callback_types] = callback_types

wrote_component(options, d, folder)
if %w[SOURCE FILTER].include?(options[:component_type])
  raise 'Missing downstream model' unless options[:downstream]
  y = load_files(options[:downstream]) 
  trace_model = Babeltrace2Gen::BTTraceClass.from_h(nil, y)
  wrote_creates(folder, trace_model, options)
end

if %w[FILTER SINK].include?(options[:component_type])
  raise 'Missing upstream models' unless options[:upstreams]
  y = load_files(options[:upstreams])
  trace_model = Babeltrace2Gen::BTTraceClass.from_h(nil, y)
  wrote_event_dispatchers(folder, trace_model, trace_matcher)
end
