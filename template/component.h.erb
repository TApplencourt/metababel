#pragma once

#include "utarray.h"
#include "uthash.h"
#include <babeltrace2/babeltrace.h>
<% if options.key?(:usr_data_header) %>
#include "<%= options[:usr_data_header] %>"
<% end %>

#ifdef __cplusplus
extern "C" {
#endif

// Forward declaration of common_data
struct common_data_s;
typedef struct common_data_s common_data_t;

// Dispatcher
typedef void(dispatcher_t)(UT_array *callbacks, common_data_t *common_data,
                           const bt_event *message);

struct name_to_dispatcher_s {
  const char *name;
  dispatcher_t *dispatcher;
  UT_array *callbacks;
  UT_hash_handle hh;
};
typedef struct name_to_dispatcher_s name_to_dispatcher_t;

<% if ['SOURCE', 'FILTER'].include?(options[:component_type]) %>
// Structure for Downstream Message
struct el {
  const bt_message *message;
  struct el *next, *prev;
};

<% end %>
// Struct stored in the component via `bt_self_component_set_data`
<% if options[:component_type] == 'SOURCE' %>
struct common_data_s {
  name_to_dispatcher_t *name_to_dispatcher;
  void *usr_data;
  const bt_value *params;
  bt_trace *downstream_trace;
  /* Used by downstream.c */
  bt_self_message_iterator *self_message_iterator;
};

enum btx_source_state_e {
  BTX_SOURCE_STATE_INITIALIZING,
  BTX_SOURCE_STATE_PROCESSING,
  BTX_SOURCE_STATE_FINALIZING,
  BTX_SOURCE_STATE_FINISHED,
  BTX_SOURCE_STATE_ERROR,
};
typedef enum btx_source_state_e btx_source_state_t;

/* Message iterator's private data */
struct btx_message_iterator_s {
  /* (Weak) link to the component's private data */
  common_data_t *common_data;
  btx_source_state_t state;

  /* Handling the downstream message queue */
  struct el *queue;
  struct el *pool;
};
typedef struct btx_message_iterator_s btx_message_iterator_t;

enum btx_source_status_e {
  BTX_SOURCE_END,
  BTX_SOURCE_OK,
};
typedef enum btx_source_status_e btx_source_status_t;

<% elsif options[:component_type] == 'FILTER' %>
struct common_data_s {
  name_to_dispatcher_t *name_to_dispatcher;
  void *usr_data;
  const bt_value *params;
  /* Component's input port (weak) */
  const bt_component_filter *component;
  bt_trace *downstream_trace;
  /* Used by downstream.c */
  bt_self_message_iterator *self_message_iterator;
};

enum btx_filter_state_e {
  BTX_FILTER_STATE_PROCESSING,
  BTX_FILTER_STATE_FINALIZING,
  BTX_FILTER_STATE_FINISHED,
  BTX_FILTER_STATE_ERROR,
};
typedef enum btx_filter_state_e btx_filter_state_t;

enum btx_filter_processing_state_e {
  BTX_FILTER_PROCESSING_STATE_READING,
  BTX_FILTER_PROCESSING_STATE_SENDING,
  BTX_FILTER_PROCESSING_STATE_FINISHED,
};
typedef enum btx_filter_processing_state_e btx_filter_processing_state_t;

typedef struct el_mi {
  /* Upstream message iterator (owned by this) */
  bt_message_iterator *message_iterator;
  struct el_mi *next, *prev;
} el_mi;

/* Message iterator's private data */
struct btx_message_iterator_s {
  /* (Weak) link to the component's private data */
  common_data_t *common_data;
  /*  Upstream messages iterator */
  el_mi *head_mi;
  btx_filter_state_t state;
  btx_filter_processing_state_t processing_state;
  /* Handling the downstream message queue */
  struct el *queue;
  struct el *pool;
};
typedef struct btx_message_iterator_s btx_message_iterator_t;

<% elsif options[:component_type] == 'SINK' %>
struct common_data_s {
  name_to_dispatcher_t *name_to_dispatcher;
  void *usr_data;
  const bt_value *params;
  /* Upstream message iterator (owned by this) */
  bt_message_iterator *message_iterator;
};
<% end %>

/* Users functions to implement */
<% if options[:component_type] == 'SOURCE'  %>
void btx_initialize_usr_data(void *btx_handle, void **usr_data);
void btx_push_usr_messages(void *btx_handle, void *usr_data, btx_source_status_t* status);
<% elsif ['FILTER', 'SINK'].include?(options[:component_type]) %>
void btx_initialize_usr_data(void *btx_handle, void **usr_data);
void btx_finalize_usr_data(void *btx_handle, void *usr_data);
<% end %>

void btx_register_usr_callbacks(void *btx_handle);

<% component_dispatchers.each do |e| %>
<%# The signature type of callbacks %>
typedef void
<%= e.name_sanitized %>_callback_f(void *btx_handle,
                                   <%= e.args.map{ |s| s.type }.join(", ") %>);
<%# The Function who register the callbacks to the dispatcher %>
extern void btx_register_callbacks_<%= e.name_sanitized %>(
    void *btx_handle, <%= e.name_sanitized %>_callback_f *callback);
<% end %>

#ifdef __cplusplus
}
#endif
