#pragma once

#include "utarray.h"
#include "uthash.h"
#include <babeltrace2/babeltrace.h>

#ifdef __cplusplus
extern "C" {
#endif

// Forward declaration of common_data
struct common_data_s;
typedef struct common_data_s common_data_t;

// Params
struct params_s {
  <%= params_declaration %>

}; <%# Need empty line for nice code gen %>
typedef struct params_s params_t;

// Dispatcher
<% if ['FILTER', 'SINK'].include?(options[:component_type]) %>
typedef void(dispatcher_t)(UT_array *callbacks, common_data_t *common_data,
                           const bt_event *message);

struct name_to_dispatcher_s {
  const char *name;
  dispatcher_t *dispatcher;
  UT_array *callbacks;
  UT_hash_handle hh;
};
typedef struct name_to_dispatcher_s name_to_dispatcher_t;

<% end %>
<% if ['SOURCE', 'FILTER'].include?(options[:component_type]) %>
// Structure for Downstream Message
struct el {
  const bt_message *message;
  struct el *next, *prev;
};

<% end %>
// Struct stored in the component via `bt_self_component_set_data`
<% if options[:component_type] == 'SOURCE' %>
struct common_data_s {
  bt_trace *downstream_trace;
  const bt_value *params;
  /* Used by create.c */
  bt_self_message_iterator *self_message_iterator;
  /* Handling the downstream message queue */
  struct el *queue;
  struct el *pool;
};
<% elsif options[:component_type] == 'FILTER' %>
struct common_data_s {
  name_to_dispatcher_t *name_to_dispatcher;
  void *usr_data;
  const bt_value *params;
  /* Component's input port (weak) */
  bt_self_component_port_input *in_port;
  bt_trace *downstream_trace;
  /* Used by create.c */
  bt_self_message_iterator *self_message_iterator;
  /* Handling the downstream message queue */
  struct el *queue;
  struct el *pool;
  /* Guarantee btx_usr_finalize in Filter is called just once. */
  bt_bool finalized;
};
<% elsif options[:component_type] == 'SINK' %>
struct common_data_s {
  name_to_dispatcher_t *name_to_dispatcher;
  void *usr_data;
  const bt_value *params;
  /* Upstream message iterator (owned by this) */
  bt_message_iterator *message_iterator;
};
<% end %>

/* Implemented by params.c */
void btx_read_params(common_data_t *common_data, params_t *usr_params);

<% if options[:component_type] == 'SOURCE'  %>
void btx_push_usr_messages(common_data_t *common_data);
<% elsif ['FILTER', 'SINK'].include?(options[:component_type]) %>
/* Users functions to implement */
void btx_initialize_usr_data(common_data_t *common_data, void **usr_data);
void btx_finalize_usr_data(common_data_t *common_data, void *usr_data);
void btx_register_usr_callbacks(name_to_dispatcher_t **name_to_dispatcher);
<% end %>

#ifdef __cplusplus
}
#endif
