#include "utarray.h"
#include "uthash.h"
#include <assert.h>
#include <babeltrace2/babeltrace.h>
#include <metababel/btx_component.h>
// stdio needed because `params_definition` contain fprintf
#include <stdio.h>

void btx_populate_params(common_data_t *common_data) {
  const bt_value *params = common_data->params;
  btx_params_t *usr_params = common_data->btx_params;
  (void)params;
  (void)usr_params;
  <%= params_definition %>
}

<% component_dispatchers.each do |e| %>

typedef void btx_dispatch_<%= e.name_sanitized %>_f(
    UT_array *callbacks, common_data_t *common_data,
    <%= e.args.map{ |s| s.type }.join(", ") %>);

static void btx_dispatch_<%= e.name_sanitized %>(
    UT_array *callbacks, common_data_t *common_data,
    <%= e.args.map{ |s| "#{s.type} #{s.name}" }.join(", ") %>) {

  // Call all the callbacks who where registered
  // Their type are declared in 'upstream.h'
  <%= e.name_sanitized %>_callback_f **p = NULL;
  while ((p = utarray_next(callbacks, p))) {
    (*p)((void *)common_data, <%= e.args.map{ |s| s.name }.join(", ") %>);
  }
}

void btx_register_callbacks_<%= e.name_sanitized %>(
    void *btx_handle, <%= e.name_sanitized %>_callback_f *callback) {
  // Look-up our dispatcher
  name_to_dispatcher_t *s = NULL;
  name_to_dispatcher_t **name_to_dispatcher =
      &((common_data_t *)btx_handle)->name_to_dispatcher;
  HASH_FIND_STR(*name_to_dispatcher, "<%= e.name %>", s);
  if (!s) {
    // We didn't find the dispatcher, so we need to:
    // 1. Create it
    s = (name_to_dispatcher_t *)malloc(sizeof(name_to_dispatcher_t));
    s->name = "<%= e.name %>";
    s->dispatcher = (void *)&btx_dispatch_<%= e.name_sanitized %>;
    utarray_new(s->callbacks, &ut_ptr_icd);
    // 2. Register it
    HASH_ADD_KEYPTR(hh, *name_to_dispatcher, s->name, strlen(s->name), s);
    // 3. Add the callbacks to the array
    utarray_push_back(s->callbacks, &callback);
  } else {
    assert(false && "Only one callbacks for <%= e.name_sanitized %>");
  }
}

void btx_call_callbacks_<%= e.name_sanitized %>(
    common_data_t *common_data,
    <%= e.args.map{ |s| "#{s.type} #{s.name}" }.join(", ") %>) {
  name_to_dispatcher_t *s = NULL;
  HASH_FIND_STR(common_data->name_to_dispatcher, "<%= e.name %>", s);

  if (s)
    (*((btx_dispatch_<%= e.name_sanitized %>_f(*))(s->dispatcher)))(
        s->callbacks, common_data, <%= e.args.map{ |s| s.name }.join(", ") %>);
}
<% end %>
