#pragma once
#include <metababel/btx_component.h>
#ifdef __cplusplus
extern "C" {
#endif

// Dispatcher
typedef void(dispatcher_t)(callbacks_t *callbacks, common_data_t *common_data,
                           const bt_message *upstream_message);

<% event_class_dispatchers.each do |e| %>
<%# The signature type of callbacks %>
typedef void <%= e.name_sanitized %>_callback_f(
    void *btx_handle,
    void *usr_data<%= ', int64_t _timestamp' if e.default_clock_class %><%= e.args.map{ |s| s.type }.join_with_prefix(", ") %>);
<%# The Function who register the callbacks to the dispatcher %>
void btx_register_callbacks_<%= e.name_sanitized %>(
    void *btx_handle, <%= e.name_sanitized %>_callback_f *callback);
<% end %>

void btx_delete_dispatchers(common_data_t *common_data);

/* Matching callbacks */

// User matching callbacks signatures
<% matching_dispatchers.each do |m| %>
typedef void (<%= m.name_sanitized %>_callback_f)(<%= m.args.map{ |s| "#{s.type} #{s.name}" }.join(", ") %>);
<% end %>

// Register matching callbacks
// NOTE: Every matching callback must be registered in 
// all the events' name_to_dispacther
<% matching_dispatchers.each do |m| %>
<% event_class_dispatchers.each do |e| %>
void btx_register_callbacks_<%= e.name_sanitized %>_<%= m.name_sanitized %>(
    void *btx_handle, <%= m.name_sanitized %>_callback_f *callback);
<% end %>
<% end %>

#ifdef __cplusplus
}
#endif
