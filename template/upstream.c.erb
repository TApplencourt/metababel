#include "utarray.h"
#include "uthash.h"
#include <assert.h>
#include <babeltrace2/babeltrace.h>
#include <metababel/btx_component.h>
#include <metababel/btx_upstream.h>
#include <stdbool.h>

<% event_class_dispatchers.each do |e| %>
static void btx_dispatch_<%= e.name_sanitized %>(
    UT_array *callbacks, common_data_t *common_data,
    const bt_message *upstream_message,
    bool *is_callback_called) {

  <%# If e.default_clock_class timestamp variable will be rendered here %>
  <% e.args.each do |s| %>
  <%= s.type %> <%= s.name %>;
  <% end %>

  const bt_event *<%= event_name %> = bt_message_event_borrow_event_const(upstream_message);
  <% if e.default_clock_class %>
  const bt_clock_snapshot *clock_snapshot = bt_message_event_borrow_default_clock_snapshot_const(upstream_message);
  bt_clock_snapshot_get_ns_from_origin(clock_snapshot, &timestamp);
  <% end %>

  <%= e.body %>
  // Call all the callbacks who where registered
  // Their type are declared in 'upstream.h'
  <%= e.name_sanitized %>_callback_f **p = NULL;
  while ((p = utarray_next(callbacks, p))) {
    <%# If e.default_clock_class timestamp variable will be rendered in function args %>
    (*p)((void *)common_data,
         common_data
             ->usr_data<%= e.args.map{ |s| s.name }.join_with_prefix(", ") %>);
  }

  if (callbacks)
    *is_callback_called = true;
}

void btx_register_callbacks_<%= e.name_sanitized %>(
    void *btx_handle, <%= e.name_sanitized %>_callback_f *callback) {
  // Look-up our dispatcher
  name_to_dispatcher_t *s = NULL;
  name_to_dispatcher_t **name_to_dispatcher =
      &((common_data_t *)btx_handle)->name_to_dispatcher;
  HASH_FIND_STR(*name_to_dispatcher, "<%= e.name %>", s);
  if (!s) {
    // We didn't find the dispatcher, so we need to:
    // 1. Create it
    s = (name_to_dispatcher_t *)malloc(sizeof(name_to_dispatcher_t));
    s->name = "<%= e.name %>";
    s->dispatcher = (void *)&btx_dispatch_<%= e.name_sanitized %>;
    utarray_new(s->callbacks, &ut_ptr_icd);
    // 2. Register it
    HASH_ADD_KEYPTR(hh, *name_to_dispatcher, s->name, strlen(s->name), s);
  }
  // Add the callbacks to the array
  utarray_push_back(s->callbacks, &callback);
}
<% end %>

<% stream_classes_matching_dispatchers.each do |s| %>
void btx_matching_dispatch_<%= s.name_sanitized %>(UT_array *callbacks,
                                                   common_data_t *common_data,
                                                   const bt_message *upstream_message,
                                                   bool *is_callback_called) {

  <%# If s.default_clock_class timestamp variable will be rendered %>
  <% s.args.each do |a| %>
  <%= a.type %> <%= a.name %>;
  <% end %>
  const bt_event *<%= event_name %> = bt_message_event_borrow_event_const(upstream_message);
  const bt_event_class *event_class = bt_event_borrow_class_const(event);
  const char *event_class_name = bt_event_class_get_name(event_class);

  const bt_stream_class *stream_class = bt_event_class_borrow_stream_class_const(event_class);
  const char *stream_class_name = bt_stream_class_get_name(stream_class);

  <%# If s.default_clock_class timestamp variable will be rendered here %>
  <% if s.default_clock_class %>
  const bt_clock_snapshot *clock_snapshot = bt_message_event_borrow_default_clock_snapshot_const(upstream_message);
  bt_clock_snapshot_get_ns_from_origin(clock_snapshot, &timestamp);
  <% end %>

  <%= s.body %>
  condition_to_callback_t **p = NULL;
  while ((p = utarray_next(callbacks, p))) {
    <%= s.name_sanitized %>_callback_condition_f *condition =
        (<%= s.name_sanitized %>_callback_condition_f *)((*p)->condition);
    <%= s.name_sanitized %>_conditioned_callback_f *callback =
        (<%= s.name_sanitized %>_conditioned_callback_f *)((*p)->callback);
    <%# If s.default_clock_class timestamp variable will be rendered in function args %>
    bool is_condition_met = false;
    condition(
        (void *)common_data, common_data->usr_data, stream_class_name, event_class_name,
        &is_condition_met<%= s.args.map{ |a| a.name }.join_with_prefix(", ") %>);
    if (is_condition_met) {
      callback(
          (void *)common_data, common_data->usr_data, stream_class_name,
          event_class_name<%= s.args.map{ |a| a.name }.join_with_prefix(", ") %>);
      *is_callback_called = true;
    }
  }
}

void btx_register_matching_callback_<%= s.name_sanitized %>(
    void *btx_handle, <%= s.name_sanitized %>_callback_condition_f *condition,
    <%= s.name_sanitized %>_conditioned_callback_f *callback) {
  // Look-up our dispatcher
  name_to_dispatcher_t *s = NULL;
  name_to_dispatcher_t **name_to_matching_dispatcher =
      &((common_data_t *)btx_handle)->name_to_matching_dispatcher;
  HASH_FIND_STR(*name_to_matching_dispatcher, "<%= s.name_sanitized %>", s);
  if (!s) {
    // We didn't find the dispatcher, so we need to:
    // 1. Create it
    s = (name_to_dispatcher_t *)malloc(sizeof(name_to_dispatcher_t));
    s->name = "<%= s.name_sanitized %>";
    s->dispatcher = (void *)&btx_matching_dispatch_<%= s.name_sanitized %>;
    utarray_new(s->callbacks, &ut_ptr_icd);
    // 2. Register it
    HASH_ADD_KEYPTR(hh, *name_to_matching_dispatcher, s->name, strlen(s->name),
                    s);
  }
  // Add the callbacks to the array
  condition_to_callback_t *m =
      (condition_to_callback_t *)malloc(sizeof(condition_to_callback_t));
  m->condition = (void *)condition;
  m->callback = (void *)callback;
  utarray_push_back(s->callbacks, &m);
}
<% end %>

void btx_delete_dispatchers(common_data_t *common_data) {
  name_to_dispatcher_t *current, *tmp;
  HASH_ITER(hh, common_data->name_to_dispatcher, current, tmp) {
    HASH_DEL(common_data->name_to_dispatcher, current);
    utarray_free(current->callbacks);
    free(current);
  }
}

void btx_delete_matching_dispatchers(common_data_t *common_data) {
  name_to_dispatcher_t *current, *tmp;
  HASH_ITER(hh, common_data->name_to_matching_dispatcher, current, tmp) {
    // Removes the item from the hash table.
    HASH_DEL(common_data->name_to_matching_dispatcher, current);
    // Deletes every condition, callback pair.
    condition_to_callback_t **p = NULL;
    while ((p = utarray_next(current->callbacks, p))) {
      free(*p);
    }
    utarray_free(current->callbacks);
    free(current);
  }
}
